# -*- mode: sh; -*-

#
# Public domain
#
# Written by Aleksey Cheusov <vle@gmx.net>
# based on the code from FAQ of comp.unix.shell newsgroup
#
# Set of shell functions for running pipe and checking
# exit statuses of ALL programs, not only last one.
#
# See pipestatus_demo for a documentation ;-)
#
# Version 0.3.0
#

# run pipe and set pipestatus_1, pipestatus_2, ... and pipesize variables
# Example: runpipe_base prog1 arg11 arg12 '|' prog2 arg21 arg22 '|' prog3
# Always return zero exit status
runpipe_base (){
    # unset pipestatus_[0-9]+ variables
    __pipestatus_j=1
    while eval "\${pipestatus_$__pipestatus_j+:} false"; do
        unset pipestatus_$__pipestatus_j
        __pipestatus_j=$(($__pipestatus_j+1))
    done

    # whole command
    __pipestatus_com=

    # token count
    __pipestatus_k=1

    # program in pipe (between |)
    __pipestatus_l=

    # counter
    __pipestatus_j=1

    # generating whole command
    for __pipestatus_a; do
        if [ "_$__pipestatus_a" = '_|' ]; then
            __pipestatus_com="$__pipestatus_com { $__pipestatus_l 3>&-"'
   echo "pipestatus_'$__pipestatus_j'=$?" 1>&3
} 4>&- |
'
            __pipestatus_j=$(($__pipestatus_j+1))
	    __pipestatus_l=
        else
            __pipestatus_l="$__pipestatus_l \"\$$__pipestatus_k\""
        fi
        __pipestatus_k=$(($__pipestatus_k+1))
    done
    __pipestatus_com="$__pipestatus_com $__pipestatus_l 3>&- 1>&4 4>&-"'
   echo "pipestatus_'"$__pipestatus_j"'=$?"'

    # '|| true' - trick for 'set -e'
    exec 4>&1 
    eval "$(exec 3>&1; eval "$__pipestatus_com")" || true
    exec 4>&- 

    #
    pipesize=$__pipestatus_j

    return 0
}

# returns zero exit status if ALL progs in pipe return zero
check_status0 (){
    __pipestatus_j=1
    while eval "\${pipestatus_$__pipestatus_j+:} false"; do
	eval "[ \$pipestatus_$__pipestatus_j -eq 0 ]" || return 1
	__pipestatus_j=$(($__pipestatus_j+1))
    done

    return 0
}

# returns zero exit status if ALL progs in pipe return zero
runpipe0 (){
    runpipe_base "$@"
    check_status0
}

# match all statuses with the pattern
# example: check_status_re '0 . 0'
# . means "any status"
check_status_re (){
    __pipestatus_re=`echo $1 | sed 's/[.]/[0-9]+/g'`
    __pipestatus_j=1
    __pipestatus_ps=
    while eval "\${pipestatus_$__pipestatus_j+:} false"; do
	eval '__pipestatus_ps="$__pipestatus_ps ${pipestatus_'$__pipestatus_j'}"'
	__pipestatus_j=$(($__pipestatus_j+1))
    done

    # trick for set -e
    if echo "$__pipestatus_ps" | egrep "^ $re"'$' > /dev/null; then
	__pipestatus_ret=$?
    else
	__pipestatus_ret=$?
    fi

    # egrep not found?
    case $__pipestatus_ret in
	0|1)
	    ;;
	*)
	    exit 2; # fatal error with egrep
    esac

    return $__pipestatus_ret
}

# match all statuses with the pattern
# example: runpipe_re '0 . 0' prog1 '|' prog2 '|' prog3
# . means "any status"
runpipe_re (){
    __pipestatus_re=$1
    shift

    runpipe_base "$@"
    check_status_re $__pipestatus_re
}

# return exit code of the last program in pipe
check_status (){
    eval return '$pipestatus_'${pipesize}
}

# similar to plain pipe but set 'pipestatus_XX' and 'pipesize' variables
runpipe (){
    runpipe_base "$@"
    check_status
}
