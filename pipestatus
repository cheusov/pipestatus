# -*- mode: sh; -*-

#
# Public domain
#
# Written by Aleksey Cheusov <vle@gmx.net>
# based on the code from FAQ of comp.unix.shell newsgroup
#
# Set of shell functions for running pipe and checking
# exit status of ALL programs, not only last one.
#
# Version 0.4.0
#

# unset variables
pipestatus_clear_all_vars (){
    # trick for 'set -e'
    unset pipesize || true

#    echo 0.1 1>&2
    # unset pipestatus_[0-9]+ variables
    __pipestatus_j=1
#    echo 0.11 1>&2
    while [ "$__pipestatus_j" -le "$pipesize" 2>/dev/null ]; do
#    while eval [ '$'"pipestatus_$__pipestatus_j" ]; do
#	echo 0.15 1>&2
        unset pipestatus_$__pipestatus_j || true
#	echo 0.16 1>&2
        __pipestatus_j=$(($__pipestatus_j+1))
#	echo 0.17 $__pipestatus_j 1>&2
    done
#    echo 0.2 1>&2
    return 0
}

# run pipe and set pipestatus_1, pipestatus_2, ... and pipesize variables
# Example: runpipe_base prog1 arg11 arg12 '|' prog2 arg21 arg22 '|' prog3
# Always return zero exit status
runpipe_base (){
    #
#    echo 0 1>&2
    pipestatus_clear_all_vars

    # whole command
    __pipestatus_com=

    # token count
    __pipestatus_k=1

    # program in pipe (between |)
    __pipestatus_l=

    # counter
    __pipestatus_j=1

#    echo 1 1>&2
    # generating whole command
    for __pipestatus_a; do
        if [ "_$__pipestatus_a" = '_|' ]; then
            __pipestatus_com="$__pipestatus_com {
   if $__pipestatus_l 3>&-"'; then
      echo "pipestatus_'$__pipestatus_j'=0" 1>&3
   else
      echo "pipestatus_'$__pipestatus_j'=$?" 1>&3
   fi
} 4>&- |
'
            __pipestatus_j=$(($__pipestatus_j+1))
	    __pipestatus_l=
        else
            __pipestatus_l="$__pipestatus_l \"\$__pipestatus_arg$__pipestatus_k\""
        fi
        __pipestatus_k=$(($__pipestatus_k+1))
    done
    __pipestatus_com="if $__pipestatus_com $__pipestatus_l 3>&- 1>&4 4>&-"'; then
      echo "pipestatus_'"$__pipestatus_j"'=0"
   else
      echo "pipestatus_'"$__pipestatus_j"'=$?"
   fi'

#    echo 2 1>&2
    # $<NUM> --> $__pipestatus_arg<NUM> for shells that supports $1..$9 only
    __pipestatus_k=1
    while [ $# -ne 0 ]; do
	eval "__pipestatus_arg$__pipestatus_k=\"$1\""
	__pipestatus_k=$(($__pipestatus_k+1))
	shift
    done

    # '|| true' - trick for 'set -e'
#    echo 3 1>&2
    exec 4>&1 
    eval "$(exec 3>&1; eval "$__pipestatus_com" || true; )"
    exec 4>&- 
#    echo 4 1>&2

    #
    pipesize=$__pipestatus_j

    # pipestatus_all
    __pipestatus_j=2
    pipestatus_all=$pipestatus_1
    while [ "$__pipestatus_j" -le "$pipesize" 2>/dev/null ]; do
	eval "pipestatus_all=\"$pipestatus_all \$pipestatus_$__pipestatus_j\""
        __pipestatus_j=$(($__pipestatus_j+1))
    done

    return 0
}

# returns zero exit status if ALL progs in pipe return zero
check_status0 (){
    __pipestatus_j=1
    while [ "$__pipestatus_j" -le "$pipesize" ]; do
	eval "[ \$pipestatus_$__pipestatus_j -eq 0 ]" || return 1
	__pipestatus_j=$(($__pipestatus_j+1))
    done

    return 0
}

# returns zero exit status if ALL progs in pipe return zero
runpipe0 (){
    runpipe_base "$@"
    check_status0
}

# match all statuses with the pattern
# example: check_status_re '0 . 0'
# . means "any status"
check_status_re (){
    __pipestatus_re=`echo $1 | sed 's/[.]/[0-9]+/g'`
    __pipestatus_j=1
    __pipestatus_ps=
    while [ "$__pipestatus_j" -le "$pipesize" ]; do
	eval '__pipestatus_ps="$__pipestatus_ps ${pipestatus_'$__pipestatus_j'}"'
	__pipestatus_j=$(($__pipestatus_j+1))
    done

#    echo '__pipestatus_re='$__pipestatus_re 1>&2
#    echo '__pipestatus_ps='$__pipestatus_ps 1>&2

    # trick for set -e
    if echo "$__pipestatus_ps" | egrep "^ $__pipestatus_re"'$' > /dev/null; then
	__pipestatus_ret=$?
    else
	__pipestatus_ret=$?
    fi

    # egrep not found?
    case "$__pipestatus_ret" in
	0|1)
	    ;;
	*)
	    exit 2; # fatal error with egrep
    esac

    return $__pipestatus_ret
}

# match all statuses with the pattern
# example: runpipe_re '0 . 0' prog1 '|' prog2 '|' prog3
# . means "any status"
runpipe_re (){
    __pipestatus_re="$1"
    shift

    runpipe_base "$@"
    check_status_re "$__pipestatus_re"
}

# return exit code of the last program in pipe
check_status (){
    eval return '$pipestatus_'${pipesize}
}

# similar to plain pipe but set 'pipestatus_XX' and 'pipesize' variables
runpipe (){
    runpipe_base "$@"
    check_status
}
