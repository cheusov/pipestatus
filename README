============================================================

pipestatus - source file for POSIX shell that allows
to obtain an exit status of every program in a pipe.

Home page. http://mova.org/~cheusov/pub/pipestatus/

============================================================

                        MOTIVATION

While programming in shell we often run pipes like this

    prog1 args1 | prog2 args2 | ... | progN argsN

Unfortunately POSIX says that exit status of the entire
pipe is the exit status of LAST program in it, i.e.
progN in our example. That is, exit status of all other
programs in pipe is silently ignored.
IMHO this is VEEEERY bad.

Solution - to check exit status of any/all programs in pipe
when it is necessary.

And this is exactly what 'pipetatus' actually does.
And this is why I packaged and publish this code.

============================================================

                         INSTALL

There is nothing to be built in 'pipestatus'.
Just copy pipestatus to the place PATH variable points to
You can also run ./pipestatus_demo for demo version and
sample of usage. ./selftest is also a good example.

If 

    make test

command fails on you system, please let me now.

============================================================

                      DOCUMENTATION

Usage:
  . pipestatus 

Provided functions:
 runpipe_base, runpipe, runpipe0, runpipe_re,
 check_status, check_status0, check_status_re

Usage for 'runpipe*' functions:
   runpipe_base         prog1 [args1] '|' prog2 [args2] '|' ...
   runpipe              prog1 [args1] '|' prog2 [args2] '|' ...
   runpipe0             prog1 [args1] '|' prog2 [args2] '|' ...
   runpipe_re status_re prog1 [args1] '|' prog2 [args2] '|' ...

All runpipeX functions set the following variables:
  - pipestatus_1   - exit status of prog1,
  - pipestatus_2   - exit status of prog2,
  - ...
  - pipestatus_all - exit status of all progN separated by space,
  - pipesize       - a number of programs in pipe.

runpipe_base - always sets $? to zero

runpipe - sets $? to the exit status of the last program
           just like normal pipes do

runpipe0 - sets $? to zero if ALL programs in pipe
            returned zero exit status

runpipe_re - sets $? to zero if concatenated statuses of
            all programs in pipe correspond to 'status_re' expression

     'status_re' argument - allowed exit statuses for pipe.
              Example1: ". 0 0". Here . means that prog1
                  may exit with ANY status, prog2 may exit with status zero,
                  and prog3 - with status zero too.
              Example2: "0 0 0 [01]". Here [01] means that last program
                  may exit with status 0 or 1,
                  while first three - with status zero.

Usage for check_statusX functions:
   check_status
   check_status0
   check_status_re status_re

They set $? according to pipestatus_1, pipestatus_2 etc. variables
(probably set by runpipeX functions)

============================================================

                       AUTHORS/FEEDBACK

Initial idea and sources was obtained
from FAQ of comp.unix.shell news group,
later the code was modified and improved
by Aleksey Cheusov <vle@gmx.net>

Send bug reports, suggestions, questions and beer ;-)
directly to me.

============================================================
